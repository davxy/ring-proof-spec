# W3F Ring Proof Specification

Base on [Vasilyev](https://hackmd.io/ulW5nFFpTwClHsD0kusJAA) notes.

## *Abstract*

This document presents a SNARK-based cryptographic scheme that allows a prover
to demonstrate knowledge of a secret scalar $t$ and its associated public key
$PK_k$​within a ring of public keys, without revealing which key is associated
with the secret. The scheme utilizes elliptic curve operations, polynomial
commitment schemes, and the Fiat-Shamir heuristic to generate non-interactive
zero-knowledge proofs. The primary goal is to prove the relation $R = PK_k + tH$.

## 1. Notation

- **Bounded Natural Numbers Sequence**: 
  - $[n] = \{0, \ldots, n-1\}$ for $n \in \mathbb{N}$
    - Represents a sequence of integers from 0 to $n-1$. For example, if $n = 5$, then $[5] = \{0, 1, 2, 3, 4\}$.

- **Kronecker Delta**:
  - $\delta_{ij} = \begin{cases} 
  1 & i = j \\ 
  0 & i \neq j 
  \end{cases}$
    - The Kronecker delta function, which is 1 if $i = j$, and 0 otherwise.

- **Vector Operations**:
    - $\overline{x}_i$
        - $i$-th element of the vector $\overline{x}$
    - $\overline{a} \| \overline{b} = (a_0, \ldots, a_{n-1}, b_0, \ldots, b_{m-1})$
        - Concatenation of two vectors $\overline{a}$ and $\overline{b}$. If $\overline{a}$ has elements $a_0, \ldots, a_{n-1}$ and $\overline{b}$ has elements $b_0, \ldots, b_{m-1}$, their concatenation is a single vector containing all elements of both vectors.

- **Repeated Element in a Vector**:
  - $x^{\|n} = (x, \ldots, x) \in X^n$ for $x \in X$ and $n \in \mathbb{N}$
    - Represents a vector of length $n$ where every element is $x$. For instance, $5^{\|3} = (5, 5, 5)$.

### 1.1. Curves and Fields

- **Subgroup of a Field**

  - $\langle \omega \rangle = \mathbb{D} \leq \mathbb{F}^*$
    - $\langle \omega \rangle$ denotes a cyclic subgroup generated by $\omega$ within the multiplicative group $\mathbb{F}^*$ of the field $\mathbb{F}$. 
  - $|\mathbb{D}| = N$
    - The size of the subgroup $\mathbb{D}$ is $N$, meaning it has $N$ elements.

- **Lagrange Basis Polynomials**

  - $\mathbb{F}[X]^{<N} \ni L_i = L_{\mathbb{D}, i},\ i \in [N]$
    - Represents the set of Lagrange basis polynomials $L_i$, where each $L_i$ is a polynomial defined over the field $\mathbb{F}$ with degree less than $N$. The condition $L_i(\omega^j) = \delta_{ij}$ means that $L_i$ evaluates to 1 at $\omega^i$ and 0 at all other $\omega^j$ for $j \neq i$.

- **Elliptic Curves**

  - $J = J / \mathbb{F}$
    - Represents an elliptic curve $J$ defined over the field $\mathbb{F}$.

  - $\tilde{\mathbb{J}} = J(\mathbb{F})$
    - The group $\tilde{\mathbb{J}}$ consists of all $\mathbb{F}$-rational points on the elliptic curve $J$.

  - $\mathbb{J} < \tilde{\mathbb{J}}$
    - $\mathbb{J}$ is a prime order subgroup of $\tilde{\mathbb{J}}$.


- **Scalar Field**

  - $\mathbb{F_J}$
      - Field associated with the elliptic curve $\mathbb{J}$. The size of this field $|\mathbb{F_J}|$ is equal to the order of $\mathbb{J}$, which has been defined to have prime order.

  - $N_J = \lceil \log_2 |\mathbb{F_J}| \rceil$:
    - $N_J$ is the number of bits needed to represent an element of $\mathbb{F_J}$.

  - $N_K = N - N_J - 4$
      - Defines the size of the ring which can be handled with a domain of size $N$.

### 1.2. Support Functions

#### Unzip

- $\text{unzip}: \mathbb{J}^k \rightarrow (\mathbb{F}^k, \mathbb{F}^k);\ \ \overline{p} \rightarrow (\overline{p}_x, \overline{p}_y)$

  - Given a vector $\overline{p}$ of $k$ elliptic curve points, the $\text{unzip}$ function separates $\overline{p}$ into two vectors: $\overline{p}_x$ and $\overline{p}_y$, containing the $x$ and $y$ coordinates of each point in $\overline{p}$, respectively.


#### Polynomial Commitment Scheme

- $\text{PCS.Commit}: \mathbb{F}[x] \rightarrow \mathbb{G};\ \ f(x) \rightarrow C_f$
    - Commit to a polynomial $f$ defined over $\mathbb{F}$ with commitment defined in a group $\mathbb{G}$. The items in $\overline{x}$ are interpolated in the domain where $\mathbb{F}[x]$ is defined.
    - When the operation is applied to a vector $\bar{x}$, the vector components are first interpolated over the domain $\mathbb{D}$ to get the polynomial $f(x)$.

- $\text{PCS.Open}: (\mathbb{G}, \mathbb{F}) \rightarrow (\mathbb{F}, \mathbb{\Pi});\ \ (C_f, x) \rightarrow (y, \pi)$
    - Evaluation of the committed polynomial $f(x)$, represented by the commitment $C_p$ in the point $x$. The opening returns the evaluation $y$ together with a proof $\pi$.
    - The proof domain $\mathbb{\Pi}$ depends on the specific PCS.

- $\text{PCS.Verify}: (\mathbb{G},\ \mathbb{F},\ \mathbb{F},\ \mathbb{\Pi}) \rightarrow \mathbb{B};\ \ (C_f, x, y , \pi) \rightarrow (0|1)$
    - Verification of the evaluation $y = f(x)$, given the commitment to the polynomial $C_f$ and the proof $\pi$.

#### Fiat-Shamir Transform

- $\text{FS}: \mathbb{A} \rightarrow \mathbb{F};\ \textbf{x} \rightarrow x$

  - Maps an object $\textbf{x} \in \mathbb{A}$ to an element in the field $\mathbb{F}$. This is typically achieved by serializing $\textbf{x}$ and then applying a cryptographically secure hash function.

### 1.3. Parameters

- $\square \in \mathbb{J}$
    - Padding element, a point on the elliptic curve $\mathbb{J}$ with an unknown discrete logarithm.
- $H \in \mathbb{J}$
    - Pedersen blinding base, a base point used in the Pedersen commitment scheme.
- $\overline{H} = (H, 2H, 4H, \ldots, 2^{N_{J-1}}H) \in \mathbb{J}^{N_J}$
    - A vector of scaled multiples of $H$.
- $S \in \tilde{\mathbb{J}} \setminus \mathbb{J}$
    - A point in the group $\tilde{\mathbb{J}}$ but not in the subgroup $\mathbb{J}$, used as a seed for an acuumulation procedure. As the accumulation adds points in $\mathbb{J}$ the result will never be the identity.

---

## 2. SNARK

### 2.1. Public Data
  
- $\overline{PK} \in \mathbb{J}^{N_K}$
  - Vector of public keys that form the ring. If the ring has fewer elements than $N_K$, the vector is padded with the padding element $\square$ to ensure the length is $N_K$.

### 2.2. Witness Data

- $k \in [N_K]$ 
  - Prover's index within the ring. This identifies which public key in the ring ($\overline{PK}$) belongs to the prover.

- $t \in \mathbb{F_J}$
  - Prover's one-time secret, an element of the scalar field $\mathbb{F_J}$.

### 2.3. Relation to Prove

- $\mathfrak{R}_H = \left\{ (R, \overline{PK}; k, t) \mid R = PK_k + tH \,;\, R \in \mathbb{J}, \, \overline{PK} \in \mathbb{J}^{N_K}, \, k \in [N_K], \, t \in \mathbb{F_J} \right\}$

  - This relation defines the conditions the prover must satisfy. The prover wants to prove that they know the index $k$ and the one-time secret key $t$ such that when you add $tH$ to the public key $\overline{PK}_k$, you obtain $R$.

### 2.4. Verifier Preprocessing
 
- $\overline{P} = \overline{PK} \| \overline{H} = (P_0, \ldots, P_{N-5}) \in \mathbb{J}^{N-4}$
  - Concatenates the vector of public keys $\overline{PK}$ with the vector $\overline{H}$. Each $P_i$ is a point on the elliptic curve, expressed as $(p_{i,x}, p_{i,y})$.

- $\overline{p}_x = (p_{x,0}, \ldots, p_{x,N-5}, 0, 0, 0, 0) \in \mathbb{F}^N$
  - Represents the x-coordinates of the points $P_i$ in $\overline{P}$, padded with four zeros to form a vector of length $N$.

- $\overline{p}_y = (p_{y,0}, \ldots, p_{y,N-5}, 0, 0, 0, 0) \in \mathbb{F}^N$
  - Represents the y-coordinates of the points $P_i$ in $\overline{P}$, also padded with four zeros to form a vector of length $N$.

- $(C_{p_x}, C_{p_y}) = (\text{PCS.Commit}(\overline{p}_x), \text{PCS.Commit}(\overline{p}_y)) \in \mathbb{G}^2$
  - Commitments to the x-coordinates and y-coordinates of the points in $\overline{P}$.

- $\overline{s} = 1^{\|N_K}\ \|\ 0^{\|N-N_K} \in \mathbb{F}^N$
  - Ring selector, a vector consisting of $N_K$ ones followed by $N-N_K$ zeros.

- $C_s = \text{PCS.Commit}(\overline{s})$
  - Commitment to the ring selector vector $\overline{s}$

### 2.5. Preprocessed Relation

$$
\mathfrak{R}^*_H = \left\{ (R, C_P; k, t, \overline{PK}) \mid PK_k + tH = R \,\land\, C_P = \text{Commit}(\overline{PK}) \,;\, R \in \mathbb{J}, \, C_P \in \mathbb{G}^2, \, k \in [N_K], \, t \in \mathbb{F_J}, \, \overline{PK} \in \mathbb{J}^{N_K} \right\}
$$

This is the preprocessed version of the original relation $\mathfrak{R}_H$, where $\text{Commit}(\overline{PK})$ is a couple composed of the PCS commitment of the commitments of the vectors $\overline{PK}_x$ and $\overline{PK}_y$ which are the components

The verifier checks that:
1. the prover knows a public key $PK_k$ and a secret $t$ such that $PK_k + tH = R$.
2. the public keys $\overline{PK}$ match the commitments $(C_{p_x}, C_{p_y})$ computed during the preprocessing step.

---

## 3. Prover

### 3.1. Witness Columns

#### 3.1.1. Bits Column

  $$
  \overline{b} = \text{col}(\overline{k} \| \overline{t} \| (0))
  $$

The column vector $\overline{b}$ is constructed by concatenating the binary vectors $\overline{k}$ and $\overline{t}$, followed by a single 0.

- $\overline{k} \in \mathbb{B}^{N_K}$
    - Binary vector representing the index $k$ in the ring. The vector $\overline{k}$ is composed of $N_K$ elements, where $k_i = \delta_{ik}$ (Kronecker delta). This means that $\overline{k}$ has a 1 in the position corresponding to the index $k$, and 0s elsewhere.
  
- $\overline{t} \in \mathbb{B}^{N_J}$
    - Binary representation of the secret scalar $t$, with $t_i$ representing the $i$-th bit of $t$ in little-endian order. The relationship is given by $\sum_{i \in [N_J]} t_i 2^i = t$
 
#### 3.1.3. Conditional Sum Accumulator Columns

$$
AC_0 = S, \quad AC_i = AC_{i-1} + b_{i-1}P_{i-1}, \quad i = 1, \ldots, N-4
$$

- **Initialization:**
    - The accumulator starts with the seed point $S$ at index 0.

- **Recursive Update:**
    - For each subsequent index $i$, the accumulator is updated based on the previous value and the product of the bit $b_{i-1}$ and the point $P_{i-1}$ from $\overline{P}$. If $b_{i-1}$ is 1, the point $P_{i-1}$ is added to the accumulator; otherwise, it remains unchanged.
  
The resulting accumulator points are again separated into $x$ and $y$ coordinates:

$$
  (\overline{ac}_x, \overline{ac}_y) = \text{unzip}(\overline{AC})
$$

Here, $\overline{ac}_x$ and $\overline{ac}_y$ are the vectors of $x$ and $y$ coordinates of the accumulator points.


#### 2.1.4. Inner Product Accumulator Column

$$
  ip_0 = 0, \quad ip_i = ip_{i-1} + b_{i-1}s_{i-1}, \quad i = 1, \ldots, N-4
$$

- **Initialization:**
    - The inner product accumulator starts at 0.

- **Recursive Update:**
    - For each subsequent index $i$, the accumulator is updated based on the previous value and the product of the bit $b_{i-1}$ and the scalar $s_{i-1}$.


### 3.2. Constraints

Polynomials interpolation over $\mathbb{D}$:

- $b(x)$ interpolates the values in $\overline{b}$ (bits).
- $s(x)$ intepolates the values in $\overline{s}$ (ring selector).
- $ip(x)$ intepolates the values in $\overline{ip}$ (inner product).
- $ac_x(x)$ interpolates the values in $\overline{ac}_x$ (conditional sum $x$ components)
- $ac_y(x)$ interpolates the values in $\overline{ac}_y$ (conditional sum $y$ components)

Note, when evaluating a polynomial $p(x)$ for some point $x = \omega^k \in \mathbb{D}$, for some $k \in \mathbb{N}$ then $p(\omega x)$ is the valuation of the poynomial in the next point in the evaluation domain ($\omega x = \omega^{k+1}$).

#### 3.2.1. Booleanity Constraint

$$
c_4(x) = b(x)\bigl(1 - b(x)\bigr)
$$

Ensures that the polynomial $b(x)$ acts as a Boolean variable, taking only values 0 or 1.

- If $b(x) = 0$ or $b(x) = 1$, then $c_4(x) = 0$.

- If $b(x)$ takes any value other than 0 or 1, $c_4(x)$ will be non-zero, violating the constraint.

#### 3.2.2. Conditional Addition Constraints

$$
\begin{aligned}
c_2(x) = & \biggl( b(x) \Bigl( \bigl( acc_x(x) - p_x(x)) ^2 \bigl( acc_x(x) + p_x(x) + acc_x(\omega x) \bigr) \\
         & \quad - \bigl( p_y(x) - acc_y(x) \bigr)^2 \Bigr) \\
         & + \bigl(1 - b(x)\bigr) \bigl( acc_x(\omega x) - acc_x(x) \bigr) \biggr) \\
         & \times (x - \omega^{N-4})
\end{aligned}
$$

$c_2(x)$ is designed to enforce the correct handling of the $x$-component during elliptic curve point addition. 

Ignoring the $(x - \omega^{N-4})$ factor:

- When $b(x) = 1$, the constraint enforces the correct elliptic curve addition for the $x$-component:

$$
c_2(x) = \bigl(ac_x(x) - p_x(x)\bigr)^2\bigl(ac_x(x) + p_x(x) + acc_x(\omega x)\bigr) - \bigl(p_y(x) - acc_y(x)\bigr)^2
$$

- When $b(x) = 0$, the constraint ensures that no addition occurs, meaning the $x$-component should remain unchanged:

$$
c_2(x) = acc_x(\omega y) - acc_y(x)
$$
     
There is a similar contstraint to enforce the correct handling of the $y$-component during elliptic curve point addition. The constraint is given by:

$$
\begin{aligned}
c_3(x) = & \biggl( b(x) \Bigl( \bigl(acc_x(x) - p_x(x)\bigr)\bigl(acc_y(\omega x) + acc_y(x)\bigr) \\
          & \quad - \bigl(p_y(x) - acc_y(x)\bigr)\bigl(acc_x(\omega x) - acc_x(x)\bigr) \Bigr) \\
          & + \bigl(1 - b(x)\bigr)\bigl(acc_x(\omega x) - acc_x(x)\bigr) \biggr) \\
          & \times (x - \omega^{N-4})
\end{aligned}
$$

- When $b(x) = 1$, the constraint enforces the correct elliptic curve addition for the $y$-component:

$$
\begin{aligned}
c_3(x) = & \bigl(acc_x(x) - p_x(x)\bigr)\bigl(acc_y(\omega x) + acc_y(x)\bigr) \\
        & - \bigl(p_y(x) - acc_y(x)\bigr)\bigl(acc_x(\omega x) - acc_x(x)\bigr)
\end{aligned}
$$
   
- When $b(x) = 0$, the constraint ensures that no addition occurs, meaning the $x$-component should remain unchanged:

$$
c_3(x) = acc_x(\omega x) - acc_x(x)
$$

The multiplication by the valishing polynomial $(x - \omega^{N-4})$ has the effect to don't enforce the "main" constraint for the point $\omega^{N-4}$.


#### 3.2.3. Conditional Addition Boundary Constraints

Given $S = (s_x, s_y)$ the conditional addition seed point and $R = (r_x, r_y)$ the conditional addition result delta from the seed point (which is the $R$ we want to prove in the relation $\mathfrak{R}_H$).

$$
c_5(x) = \bigl(acc_x(x) - s_x\bigr)L_0(x) + \bigl(acc_x(x) - r_x - s_x\bigr)L_{N-4}(x)
$$

Ensures the $x$-component of the accumulator $acc_x(x)$ takes specific values at boundary points in the evaluation domain.

- At $x = \omega^0$: $acc_x(\omega^0) = s_x$ enforced by $L_0(x)$.

- At $x = \omega^{N-4}$: $acc_x(\omega^{N-4}) = r_x + s_x$ enforced by $L_{N-4}(x)$.
  
Lagrange Polynomials $L_0(x)$ and $L_{N-4}(x)$ ensure these conditions hold exactly at the specified points.

There is a similar contstraint to enforce the correct handling of the $y$-component:

$$
c_6(x)=\bigl(acc_y(x)-s_y\bigr)L_0(x)+\bigl(acc_y(x)-r_y-s_y\bigr)L_{N-4}(x)
$$

- At $x = \omega^0$: $acc_y(\omega^0) = s_y$ enforced by $L_0(x)$.

- At $x = \omega^{N-4}$: $acc_y(\omega^{N-4}) = r_y + s_y$ enforced by $L_{N-4}(x)$.


#### 3.2.4. Inner Product Constraint

$$
c_1(x) = \bigl(ip(\omega x) - ip(x) - b(x)s(x)\bigr)(x - \omega^{N-4})
$$

Ensures the inner product accumulator $ip(x)$ is correctly updated as $ip(\omega x) = ip(x) + b(x)s(x)$.

The factor $(x - \omega^{N-4})$ ensures the constraint holds for all points except $x = \omega^{N-4}$, where $c_1(x)$ automatically vanishes.

#### 3.2.5. Inner Product Boundary Constraint

$$
c_7(x) = acc_{ip}(x)L_0(x) + \bigl(acc_{ip}(x) - 1\bigr)L_{N-4}(x)
$$

This constraint ensures the correct initialization and finalization of the inner product accumulator $acc_{ip}(x)$ at specific boundary points in the evaluation domain. In practice requires the accumulato to start from $0$ and end at $1$.


- At $x = \omega^0$: The term $acc_{ip}(x)$ is enforced to be 0 by $L_0(x)$.

- At $x = \omega^{N-4}$: The term $acc_{ip}(x)$ is enforced to be 1 by $L_{N-4}(x)$


### 3.3 - Commitments and Sampling

Instead of checking each constraint individually, the protocol combines them into a single aggregated constraint polynomial.
 
#### 3.3.1 - Compute Commitments

Commit to the key columns using the PCS:

$$
\begin{align*}
C_b &= \text{PCS.Commit}(b) \\
C_{ip} &= \text{PCS.Commit}(ip) \\
C_{ac_x} &= \text{PCS.Commit}(ac_x) \\
C_{ac_y} &= \text{PCS.Commit}(ac_y)
\end{align*}
$$

#### 3.3.2. Sample Aggregation Coefficients


Use the Fiat-Shamir (FS) heuristic to sample the constraint aggregation coefficients:

$$
   \{\alpha_i\}_{i=1}^7 \leftarrow \text{FS}(C_b, C_{ip}, C_{ac_x}, C_{ac_y})
$$

The coefficients $\alpha_i$ will be used to aggregate the constraints in the final proof.


#### 3.3.3. Composition of the Polynomial

The final polynomial $c(x)$ is constructed as:

$$
c(x) = \left(\sum_{i=1}^7 \alpha_i c_i(x)\right) \cdot \prod_{k=1}^3 \left(x - \omega^{N-k}\right)
$$

- The term $\sum_{i=1}^7 \alpha_i c_i(x)$ is a linear combination of the constraint polynomials $c_i(x)$, weighted by the coefficients $\alpha_i$.

- The product $\prod_{k=1}^3 \left(x - \omega^{N-k}\right)$ ensures $c(x)$ vanishes at $x = \omega^{N-1}$, $\omega^{N-2}$, $\omega^{N-3}$. This vanishing polynomial enforces that the constraints hold across the entire evaluation domain, including the last three points, ensuring thorough and robust constraint checking.

#### 3.3.4. Quotient Polynomial

The quotient polynomial is computed as:

$$
q(x) = \frac{c(x)}{X^N - 1}
$$

Dividing by $X^N - 1$ ensures that the aggregated constraints encoded in $c(x)$ are enforced across the entire evaluation domain $\mathbb{D}$. The division reduces the degree of the resulting polynomial, making it appropriate for further steps in the SNARK protocol.

#### 3.3.5. Commit to the quotient polynomial and sample evaluation point

Prover commits to the quotient polynomial $q$
$$
C_q = \text{PCS.Commit}(q)
$$

And receives the evaluation point $\zeta$ in reponse

$$
\zeta \leftarrow \text{FS}(C_q)
$$

#### 3.3.6. Quotient Polynomial Evaluation

Evaluate the relevant polynomials at the sampled evaluation point $\zeta$

$$p_{x,\zeta}=p_x(\zeta)$$

$$p_{y,\zeta}=p_y(\zeta)$$

$$s_\zeta=s(\zeta)$$

$$b_\zeta=b(\zeta)$$

$$acc_{ip,\zeta}=acc_{ip}(\zeta)$$

$$acc_{x,\zeta}=acc_x(\zeta)$$

$$acc_{y,\zeta}=acc_y(\zeta)$$

#### 3.3.7. Linearization Polynomial

Linearized parts of constraint polynomials.

TODO: describe the motivation

Accumulator inner product ($c_1$) linearized:

$$l_1(x)=(\zeta - \omega^{N-4})acc_{ip}(x)$$

Conditional addition accumulators ($c_{2,3}$) linearized:

$$l_2(X)=(\zeta-\omega^{N-4})\bigl(b_\zeta(acc_{x,\zeta}-p_{x,\zeta})^2acc_x(X)+(1-b_\zeta)acc_y(X)\bigr)$$

$$l_3(X)=(\zeta-\omega^{N-4})\Bigl(\bigl(b_\zeta(acc_{y,\zeta}-p_{y,\zeta})+1-b_\zeta\bigr)acc_x(X)+b_\zeta(acc_{x,\zeta}-p_{x,\zeta})acc_y(X)\Bigr)$$

Booleanity ($c_4$) and boundary constraints ($c_{5..7}(x)$) linearized

$$l_4(x) = l_5(x) = l_6(x) = l_7(x) = 0$$ 

Linearized constraints are aggregated using $\{\alpha_i\}$ coefficients and evaluated at $\zeta \omega$:

$$l(x)=\sum_{i=1}^7\alpha_i l_i(x)$$

$$l_{\zeta\omega}=l(\zeta\omega)$$

#### 3.3.8. Sample PCS aggregation coefficients

$\nu_i$ and compute the aggregate polynomial $agg$.

$$
\{\nu_i\}_{i=1}^8 \leftarrow \text{FS}(p_{x,\zeta}, p_{y,\zeta}, s_\zeta, b_\zeta, acc_{ip,\zeta}, acc_{x,\zeta}, acc_{y,\zeta}, l_{\zeta\omega})
$$

$$
agg(x)=\nu_1p_x(x)+\nu_2p_y(x)+\nu_3s(x)+\nu_4b(x)+\nu_5acc_{ip}(x)+\nu_6acc_x(x)+\nu_7acc_y(x)+\nu_8q(x)
$$

#### 3.3.9. Commitments Openings Proofs

Open the aggregate polynomial $agg(x)$ at $\zeta$ and the linearization polynomial $l(x)$ at $\zeta\omega$.

$$\Pi_\zeta=PCS.Open(agg,\zeta)$$

$$\Pi_{\zeta\omega}=PCS.Open(l,\zeta\omega)$$

#### 3.3.10. Proof construction

$$\Pi=(C_b,C_{acc_{ip}},C_{acc_x},C_{acc_y},p_{x,\zeta},p_{y,\zeta},s_\zeta,b_\zeta,acc_{ip,\zeta},acc_{x,\zeta},acc_{y,\zeta},C_q,l_{\zeta\omega},\Pi_\zeta,\Pi_{\zeta\omega})$$


---

## 4. Verifier

### 4.1. Inputs

#### 4.1.1. Pre-processed Commitments

$$(C_{p_x}, C_{p_y}, C_s)$$

These are commitments to the $x$-coordinates and $y$-coordinates of the public keys in the ring and ring selector prepared during the pre-processing phase.

#### 4.1.2. Public Input

$$R = (r_x, r_y)$$
 
The claimed point on the elliptic curve, allegedly $PK_m + tH + S$, where:
- $PK_m$ is the public key corresponding to the validator’s index $m$ who prepared the proof.
- $t$ is the validator’s one-time secret scalar.
- $H$ is a known base point.

#### 4.1.3. Proof

$$
\Pi = (C_b, C_{acc_{ip}}, C_{acc_x}, C_{acc_y}, p_{x,\zeta}, p_{y,\zeta}, s_\zeta, b_\zeta, ip_{\zeta}, ac_{x,\zeta}, ac_{y,\zeta}, C_q, l_{\zeta\omega}, \Pi_\zeta, \Pi_{\zeta\omega})
$$

- Commitments: $C_b, C_{acc_{ip}}, C_{acc_x}, C_{acc_y}, C_q$
- Evaluations: $p_{x,\zeta}, p_{y,\zeta}, s_\zeta, b_\zeta, acc_{ip,\zeta}, acc_{x,\zeta}, acc_{y,\zeta}$
- Opening Proofs: $\Pi_\zeta, \Pi_{\zeta\omega}$

### 4.2. Verification

#### 4.2.1. Fiat-Shamir Challenges Recovery

$$\{\alpha_i\}_{i=1}^7 \leftarrow \text{FS}(C_b, C_{ip}, C_{acc_x}, C_{acc_y})$$

$$\zeta \leftarrow \text{FS}(C_q)$$

$$\{\nu_i\}_{i=1}^8 \leftarrow \text{FS}(p_{x,\zeta}, p_{y,\zeta}, s_\zeta, b_\zeta, acc_{ip,\zeta}, acc_{x,\zeta}, acc_{y,\zeta}, l_{\zeta\omega})$$

#### 4.2.2. Contributions of the Constraints Evaluated at $\zeta$

$$\tilde{c}_{1,\zeta}=-(acc_{ip,\zeta}+b_\zeta s_\zeta)(\zeta-\omega^{N-4})$$

$$\tilde{c}_{2,\zeta}=\left\{b_\zeta\left[(acc_{x,\zeta}-p_{x,\zeta})^2(acc_{x,\zeta}+p_{x,\zeta})-(p_{y,\zeta}-acc_{y,\zeta})^2\right]-(1-b_\zeta)acc_{y,\zeta}\right\}(\zeta-\omega^{N-4})$$

$$\tilde{c}_{3,\zeta}=\left\{b_\zeta\left[(acc_{x,\zeta}-p_{x,\zeta})acc_{y,\zeta}+(p_{y,\zeta}-acc_{y,\zeta})acc_{x,\zeta}\right]-(1-b_\zeta)acc_{x,\zeta}\right\}(\zeta-\omega^{N-4})$$

$$c_4=b_{\zeta}(1-b_{\zeta})$$

$$c_5=(acc_{x,\zeta}-s_x)L_0(\zeta)+(acc_{x,\zeta}-r_x-s_x)L_{N-4}(\zeta)$$

$$c_6=(acc_{y,\zeta}-s_y)L_0(\zeta)+(acc_{y,\zeta}-r_y-s_y)L_{N-4}(\zeta)$$

$$c_7=acc_{ip,\zeta}L_0(\zeta)+(acc_{ip,\zeta}-1)L_{N-4}(\zeta)$$

Note the *tilde* above the first three polynomials, this makes explicit the fact that these are only a part of the constraint, i.e. only the component evaluated at $x = \zeta$. They are missing the component evaluated at $x \omega = \zeta \omega$ which is added later by the linearization aggregated polynomial $l_{\zeta\omega}$.

#### 4.2.3. Evaluation of the Quotient Polynomial at $\zeta$

Aggregate the contributions together with the linearization polynomial evaluated at $\zeta \omega$ to find the evaluation of the quotient polynomial at $\zeta$:

$$q_{\zeta}=\frac{(\sum_{i=1}^7\alpha_ic_i+l_{\zeta\omega})\prod_{k=1}^3(\zeta-\omega^{N-k})}{\zeta^N-1}$$
   
#### 4.2.4. Verify the Aggregate Opening at $\zeta$

Compute the aggregate commitment $C_{agg}$ using the PCS aggregation coefficients $\nu_i$:

$$C_{agg} = \nu_1 C_{p_x} + \nu_2 C_{p_y} + \nu_3 C_s + \nu_4 C_b + \nu_5 C_{acc_{ip}} + \nu_6 C_{acc_x} + \nu_7 C_{acc_y} + \nu_8 C_q$$
  

Compute the aggregate evaluation $agg_\zeta$ using the same coefficients:

$$agg_\zeta = \nu_1 p_{x,\zeta} + \nu_2 p_{y,\zeta} + \nu_3 s_\zeta + \nu_4 b_\zeta + \nu_5 acc_{ip,\zeta} + \nu_6 acc_{x,\zeta} + \nu_7 acc_{y,\zeta} + \nu_8 q_\zeta$$

Verify the aggregate polynomial at $\zeta$ with the opening proof $\Pi_\zeta$:

$$\text{PCS.Verify}(C_{agg}, \zeta, agg_\zeta, \Pi_\zeta)$$

#### 4.2.5. Compute Linearization Polynomial Commitment

$$C_{l_1}=(\zeta-\omega^{N-4})C_{acc_{ip}}$$

$$C_{l_2}=(\zeta-\omega^{N-4})\left[b_\zeta(acc_{x,\zeta}-p_{x,\zeta})^2C_{acc_x}+(1-b_\zeta)C_{acc_y}\right]$$

$$C_{l_3}=(\zeta-\omega^{N-4})\left\{\left[b_\zeta(acc_{y,\zeta}-p_{y,\zeta})+1-b_\zeta\right]C_{acc_x}+b_\zeta(acc_{x,\zeta}-p_{x,\zeta}) C_{acc_y}\right\}$$

$$C_l=\sum_{i=1}^3\alpha_iC_{l_i}$$

#### 4.2.6. Verify Linearization Polynomial Openning at $\zeta\omega$

$$\text{PCS.Verify}(C_{l},\zeta\omega,l_{\zeta\omega},\Pi_{\zeta\omega})$$
