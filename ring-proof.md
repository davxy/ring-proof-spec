# Ring Proof

[Vasilyev](https://hackmd.io/ulW5nFFpTwClHsD0kusJAA) extended version.

## *Abstract*

This document presents a SNARK-based cryptographic scheme that allows a prover
to demonstrate knowledge of a secret scalar $t$ and its associated public key
$PK_k$​within a ring of public keys, without revealing which key is associated
with the secret. The scheme utilizes elliptic curve operations, polynomial
commitment schemes, and the Fiat-Shamir heuristic to generate non-interactive
zero-knowledge proofs. The primary goal is to prove the relation $R = PK_k + tH$.

## Notation

- **Bounded Natural Numbers Sequence**: 
  - $[n] = \{0, \ldots, n-1\}$ for $n \in \mathbb{N}$
    - Represents a sequence of integers from 0 to $n-1$. For example, if $n = 5$, then $[5] = \{0, 1, 2, 3, 4\}$.

- **Kronecker Delta**:
  - $\delta_{ij} = \begin{cases} 
  1 & i = j \\ 
  0 & i \neq j 
  \end{cases}$
    - The Kronecker delta function, which is 1 if $i = j$, and 0 otherwise.

- **Vector Operations**:
    - $\overline{x}_i$
        - $i$-th element of the vector $\overline{x}$
    - $\overline{a} \| \overline{b} = (a_0, \ldots, a_{n-1}, b_0, \ldots, b_{m-1})$
        - Concatenation of two vectors $\overline{a}$ and $\overline{b}$. If $\overline{a}$ has elements $a_0, \ldots, a_{n-1}$ and $\overline{b}$ has elements $b_0, \ldots, b_{m-1}$, their concatenation is a single vector containing all elements of both vectors.

- **Repeated Element in a Vector**:
  - $x^{\|n} = (x, \ldots, x) \in X^n$ for $x \in X$ and $n \in \mathbb{N}$
    - Represents a vector of length $n$ where every element is $x$. For instance, $5^{\|3} = (5, 5, 5)$.

## Curves and Fields

- **Subgroup of a Field**:
  - $\langle \omega \rangle = \mathbb{D} \leq \mathbb{F}^*$
    - $\langle \omega \rangle$ denotes a cyclic subgroup generated by $\omega$ within the multiplicative group $\mathbb{F}^*$ of the field $\mathbb{F}$. 
  - $|\mathbb{D}| = N$
    - The size of the subgroup $\mathbb{D}$ is $N$, meaning it has $N$ elements.

- **Lagrange Basis Polynomials**:
  - $\mathbb{F}[X]^{<N} \ni L_i = L_{\mathbb{D}, i},\ i \in [N]$
    - Represents the set of Lagrange basis polynomials $L_i$, where each $L_i$ is a polynomial defined over the field $\mathbb{F}$ with degree less than $N$. The condition $L_i(\omega^j) = \delta_{ij}$ means that $L_i$ evaluates to 1 at $\omega^i$ and 0 at all other $\omega^j$ for $j \neq i$.

- **Elliptic Curves**:
  - $J = J / \mathbb{F}$
    - Represents an elliptic curve $J$ defined over the field $\mathbb{F}$.

  - $\tilde{\mathbb{J}} = J(\mathbb{F})$
    - The group $\tilde{\mathbb{J}}$ consists of all $\mathbb{F}$-rational points on the elliptic curve $J$.

  - $\mathbb{J} < \tilde{\mathbb{J}}$
    - $\mathbb{J}$ is a prime order subgroup of $\tilde{\mathbb{J}}$.


- **Scalar Field**:

  - $\mathbb{F_J}$
      - Field associated with the elliptic curve $\mathbb{J}$. The size of this field $|\mathbb{F_J}|$ is equal to the order of $\mathbb{J}$, which has been defined to have prime order.

  - $N_J = \lceil \log_2 |\mathbb{F_J}| \rceil$:
    - $N_J$ is the number of bits needed to represent an element of $\mathbb{F_J}$.

  - $N_K = N - N_J - 4$
      - Defines the **size of the ring** which can be handled with a domain of size $N$. 

- **Polynomial Commitment Scheme (PCS)**:

  - $PCS.Commit(\overline{x}): \mathbb{F}[X] \longrightarrow \mathbb{G}$
    - Represents a commitment function in a Polynomial Commitment Scheme, where a polynomial over $\mathbb{F}$ is committed to a point in group $\mathbb{G}$.
    - The items in $\overline{x}$ are interpolated in the domain where $\mathbb{F}[X]$ is defined.


## Parameters

- $\square \in \mathbb{J}$
    - Padding element, a point on the elliptic curve $\mathbb{J}$ with an unknown discrete logarithm.
- $H \in \mathbb{J}$
    - Pedersen blinding base, a base point used in the Pedersen commitment scheme.
- $\overline{H} = (H, 2H, 4H, \ldots, 2^{N_{J-1}}H) \in \mathbb{J}^{N_J}$
    - A vector of scaled multiples of $H$.
- $S \in \tilde{\mathbb{J}} \setminus \mathbb{J}$
    - A point in the group $\tilde{\mathbb{J}}$ but not in the subgroup $\mathbb{J}$, used as a seed for an accumulator. As the accumulation procedure adds points in $\mathbb{J}$ the result will never be the identity.


---

## SNARK

### Shared Data

- $\overline{PK} \in \mathbb{J}^{N_K}$
  - Vector of public keys that form the ring. If the ring has fewer elements than $N_K$, the vector is padded with the padding element $\square$ to ensure the length is $N_K$.

### Prover's Secrets

- $k \in [N_K]$ 
  - Prover's index within the ring. This identifies which public key in the ring ($\overline{PK}$) belongs to the prover.

- $t \in \mathbb{F_J}$
  - Prover's one-time secret, an element of the scalar field $\mathbb{F_J}$.

### The Relation to Prove

- $\mathfrak{R}_H = \left\{ (R, \overline{PK}; k, t) \mid R = PK_k + tH \,;\, R \in \mathbb{J}, \, \overline{PK} \in \mathbb{J}^{N_K}, \, k \in [N_K], \, t \in \mathbb{F_J} \right\}$

  - This relation defines the conditions the prover must satisfy. The prover wants to prove that they know the index $k$ and the one-time secret key $t$ such that when you add $tH$ to the public key $\overline{PK}_k$, you obtain $R$.

### Verifier Preprocessing
 
- $\overline{P} = \overline{PK} \| \overline{H} = (P_0, \ldots, P_{N-5}) \in \mathbb{J}^{N-4}$
  - Concatenates the vector of public keys $\overline{PK}$ with the vector $\overline{H}$. Each $P_i$ is a point on the elliptic curve, expressed as $(p_{i,x}, p_{i,y})$.

- $\overline{p}_x = (p_{x,0}, \ldots, p_{x,N-5}, 0, 0, 0, 0) \in \mathbb{F}^N$
  - Represents the x-coordinates of the points $P_i$ in $\overline{P}$, padded with four zeros to form a vector of length $N$.

- $\overline{p}_y = (p_{y,0}, \ldots, p_{y,N-5}, 0, 0, 0, 0) \in \mathbb{F}^N$
  - Represents the y-coordinates of the points $P_i$ in $\overline{P}$, also padded with four zeros to form a vector of length $N$.

- $(C_{p_x}, C_{p_y}) = (\text{PCS.Commit}(\overline{p_x}), \text{PCS.Commit}(\overline{p_y})) \in \mathbb{G}^2$
  - Commitments to the x-coordinates and y-coordinates of the points in $\overline{P}$.

- $\overline{s} = 1^{\|N_K}\ \|\ 0^{\|N-N_K} \in \mathbb{F}^N$
  - Ring selector, a vector consisting of $N_K$ ones followed by $N-N_K$ zeros.

- $C_s = \text{PCS.Commit}(\overline{s})$
  - Commitment to the ring selector vector $\overline{s}$

### Preprocessed Relation

$$
\mathfrak{R}^*_H = \left\{ (R, C_P; k, t, \overline{PK}) \mid PK_k + tH = R \,\land\, C_P = \text{CommitKeys}_H(\overline{PK}) \,;\, R \in \mathbb{J}, \, C_P \in \mathbb{G}^2, \, k \in [N_K], \, t \in \mathbb{F_J}, \, \overline{PK} \in \mathbb{J}^{N_K} \right\}
$$

This is the preprocessed version of the original relation $\mathfrak{R}_H$, where the verifier checks two things:
1. That the prover knows a public key $PK_k$ and a secret $t$ such that $PK_k + tH = R$.
2. That the public keys $\overline{PK}$ match the commitments $(C_{p_x}, C_{p_y})$ computed during the preprocessing step.

---

## 2 - Prover

### 2.1 - Witness Columns

#### 2.1.1 - Bits Column

  $$
  \overline{b} = \text{col}(\overline{k} \| \overline{t} \| (0))
  $$

The column vector $\overline{b}$ is constructed by concatenating the binary vectors $\overline{k}$ and $\overline{t}$, followed by a single 0.

- $\overline{k} \in \mathbb{B}^{N_K}$
    - Binary vector representing the index $k$ in the ring. The vector $\overline{k}$ is composed of $N_K$ elements, where $k_i = \delta_{ik}$ (Kronecker delta). This means that $\overline{k}$ has a 1 in the position corresponding to the index $k$, and 0s elsewhere.
  
- $\overline{t} \in \mathbb{B}^{N_J}$
    - Binary representation of the secret scalar $t$, with $t_i$ representing the $i$-th bit of $t$ in little-endian order. The relationship is given by $\sum_{i \in [N_J]} t_i 2^i = t$
 
#### 2.1.2 - Input Points Columns

  $$
  \overline{P}
  $$

The vector $\overline{P}$ contains elliptic curve points. These points are then separated into their $x$ and $y$ coordinates using the *unzip* operation:

  $$
  (\overline{p}_x, \overline{p}_y) = \text{unzip}(\overline{P})
  $$

Here, $\overline{p}_x$ and $\overline{p}_y$ are the vectors of $x$ and $y$ coordinates of the points in $\overline{P}$, respectively.


#### 2.1.3 - Conditional Sum Accumulator Columns

$$
  AC_0 = S, \quad AC_i = AC_{i-1} + b_{i-1}P_{i-1}, \quad i = 1, \ldots, N-4
$$

- **Initialization:**
    - The accumulator starts with the seed point $S$ at index 0.

- **Recursive Update:**
    - For each subsequent index $i$, the accumulator is updated based on the previous value and the product of the bit $b_{i-1}$ and the point $P_{i-1}$ from $\overline{P}$. If $b_{i-1}$ is 1, the point $P_{i-1}$ is added to the accumulator; otherwise, it remains unchanged.
  
The resulting accumulator points are again separated into $x$ and $y$ coordinates:

$$
  (\overline{ac}_x, \overline{ac}_y) = \text{unzip}(\overline{AC})
$$

Here, $\overline{ac}_x$ and $\overline{ac}_y$ are the vectors of $x$ and $y$ coordinates of the accumulator points.


#### 2.1.4 - Inner Product Accumulator Column

$$
  ip_0 = 0, \quad ip_i = ip_{i-1} + b_{i-1}s_{i-1}, \quad i = 1, \ldots, N-4
$$

- **Initialization:**
    - The inner product accumulator starts at 0.

- **Recursive Update:**
    - For each subsequent index $i$, the accumulator is updated based on the previous value and the product of the bit $b_{i-1}$ and the scalar $s_{i-1}$.


### 2.2 - Constraints

Polynomials interpolation over $\mathbb{D}$:

- $b(x)$ interpolates the values in $\overline{b}$ (bits).
- $s(x)$ intepolates the values in $\overline{s}$ (ring selector).
- $ip(x)$ intepolates the values in $\overline{ip}$ (inner product).
- $ac_x(x)$ interpolates the values in $\overline{ac}_x$ (conditional sum $x$ components)
- $ac_y(x)$ interpolates the values in $\overline{ac}_y$ (conditional sum $y$ components)

Note, when evaluating a polynomial $p(x)$ for some point $x = \omega^k \in \mathbb{D}$, for some $k \in \mathbb{N}$ then $p(\omega x)$ is the valuation of the poynomial in the next point in the evaluation domain ($\omega x = \omega^{k+1}$).

#### 2.2.1 - Booleanity constraint

$$
c_4(x) = b(x)\bigl(1 - b(x)\bigr)
$$

Ensures that the polynomial $b(x)$ acts as a Boolean variable, taking only values 0 or 1.

- If $b(x) = 0$ or $b(x) = 1$, then $c_4(x) = 0$.

- If $b(x)$ takes any value other than 0 or 1, $c_4(x)$ will be non-zero, violating the constraint.

#### 2.2.2 - Conditional Addition Constraints

$$
\begin{aligned}
c_2(x) = & \biggl( b(x) \Bigl( \bigl( acc_x(x) - p_x(x)) ^2 \bigl( acc_x(x) + p_x(x) + acc_x(\omega x) \bigr) \\
         & \quad - \bigl( p_y(x) - acc_y(x) \bigr)^2 \Bigr) \\
         & + \bigl(1 - b(x)\bigr) \bigl( acc_x(\omega x) - acc_x(x) \bigr) \biggr) \\
         & \times (x - \omega^{N-4})
\end{aligned}
$$

$c_2(x)$ is designed to enforce the correct handling of the $x$-component during elliptic curve point addition. 

Ignoring the $(x - \omega^{N-4})$ factor:

- When $b(x) = 1$, the constraint enforces the correct elliptic curve addition for the $x$-component:
     $$
     c_2(x) = \bigl(ac_x(x) - p_x(x)\bigr)^2\bigl(ac_x(x) + p_x(x) + acc_x(\omega x)\bigr) - \bigl(p_y(x) - acc_y(x)\bigr)^2
     $$

- When $b(x) = 0$, the constraint ensures that no addition occurs, meaning the $x$-component should remain unchanged:
     $$
     c_2(x) = acc_x(\omega x) - acc_x(x)
     $$
     
There is a similar contstraint to enforce the correct handling of the $y$-component during elliptic curve point addition. The constraint is given by:

$$
\begin{aligned}
c_3(x) = & \biggl( b(x) \Bigl( \bigl(acc_x(x) - p_x(x)\bigr)\bigl(acc_y(\omega x) + acc_y(x)\bigr) \\
          & \quad - \bigl(p_y(x) - acc_y(x)\bigr)\bigl(acc_x(\omega x) - acc_x(x)\bigr) \Bigr) \\
          & + \bigl(1 - b(x)\bigr)\bigl(acc_x(\omega x) - acc_x(x)\bigr) \biggr) \\
          & \times (x - \omega^{N-4})
\end{aligned}
$$

- When $b(x) = 1$, the constraint enforces the correct elliptic curve addition for the $y$-component:
     $$
     c_3(x) = \bigl(acc_x(x) - p_x(x)\bigr)\bigl(acc_y(\omega x) + acc_y(x)\bigr) - \bigl(p_y(x) - acc_y(x)\bigr)\bigl(acc_x(\omega x) - acc_x(x)\bigr)
     $$
   
- When $b(x) = 0$, the constraint ensures that no addition occurs, meaning the $x$-component should remain unchanged:
     $$
     c_3(x) = acc_x(\omega x) - acc_x(x)
     $$

TODO: In Vasilyev code and text this is set to $x$ component, shouldn't be $y$ instead?

The multiplication by the valishing polynomial $(x - \omega^{N-4})$ has the effect to don't enforce the "main" constraint for the point $\omega^{N-4}$.


#### 2.2.3 - Conditional addition boundary constraints

Given $S = (s_x, s_y)$ the conditional addition seed point and $R = (r_x, r_y)$ the conditional addition result delta from the seed point (which is the $R$ we want to prove in the relation $\mathfrak{R}_H$).

$$
c_5(x) = \bigl(acc_x(x) - s_x\bigr)L_0(x) + \bigl(acc_x(x) - r_x - s_x\bigr)L_{N-4}(x)
$$

Ensures the $x$-component of the accumulator $acc_x(x)$ takes specific values at boundary points in the evaluation domain.

- At $x = \omega^0$: $acc_x(\omega^0) = s_x$ enforced by $L_0(x)$.

- At $x = \omega^{N-4}$: $acc_x(\omega^{N-4}) = r_x + s_x$ enforced by $L_{N-4}(x)$.
  
Lagrange Polynomials $L_0(x)$ and $L_{N-4}(x)$ ensure these conditions hold exactly at the specified points.

There is a similar contstraint to enforce the correct handling of the $y$-component:

$$
c_6(x)=\bigl(acc_y(x)-s_y\bigr)L_0(x)+\bigl(acc_y(x)-r_y-s_y\bigr)L_{N-4}(x)
$$

- At $x = \omega^0$: $acc_y(\omega^0) = s_y$ enforced by $L_0(x)$.

- At $x = \omega^{N-4}$: $acc_y(\omega^{N-4}) = r_y + s_y$ enforced by $L_{N-4}(x)$.


#### 2.2.4 - Inner Product Constraint

$$
c_1(x) = \bigl(ip(\omega x) - ip(x) - b(x)s(x)\bigr)(x - \omega^{N-4})
$$

Ensures the inner product accumulator $ip(x)$ is correctly updated as $ip(\omega x) = ip(x) + b(x)s(x)$.

The factor $(x - \omega^{N-4})$ ensures the constraint holds for all points except $x = \omega^{N-4}$, where $c_1(x)$ automatically vanishes.

#### 2.2.5 - Inner Product Boundary Constraint

$$
c_7(x) = acc_{ip}(x)L_0(x) + \bigl(acc_{ip}(x) - 1\bigr)L_{N-4}(x)
$$

This constraint ensures the correct initialization and finalization of the inner product accumulator $acc_{ip}(x)$ at specific boundary points in the evaluation domain. In practice requires the accumulato to start from $0$ and end at $1$.


- At $x = \omega^0$: The term $acc_{ip}(x)$ is enforced to be 0 by $L_0(x)$.

- At $x = \omega^{N-4}$: The term $acc_{ip}(x)$ is enforced to be 1 by $L_{N-4}(x)$


### 2.3 - Commitments and Sampling

Instead of checking each constraint individually, the protocol combines them into a single aggregated constraint polynomial.
 
#### 2.3.1 - Compute Commitments

Commit to the key columns using the PCS:

$$
\begin{align*}
C_b &= \text{PCS.Commit}(b) \\
C_{ip} &= \text{PCS.Commit}(ip) \\
C_{ac_x} &= \text{PCS.Commit}(ac_x) \\
C_{ac_y} &= \text{PCS.Commit}(ac_y)
\end{align*}
$$

#### 2.3.2 - Sample Aggregation Coefficients


Use the Fiat-Shamir (FS) heuristic to sample the constraint aggregation coefficients:

$$
   \{\alpha_i\}_{i=1}^7 \leftarrow \text{FS}(C_b, C_{ip}, C_{ac_x}, C_{ac_y})
$$

The coefficients $\alpha_i$ will be used to aggregate the constraints in the final proof.


#### 2.3.3 - Composition of the Polynomial

The final polynomial $c(x)$ is constructed as:

$$
c(x) = \left(\sum_{i=1}^7 \alpha_i c_i(x)\right) \cdot \prod_{k=1}^3 \left(x - \omega^{N-k}\right)
$$

- The term $\sum_{i=1}^7 \alpha_i c_i(x)$ is a linear combination of the constraint polynomials $c_i(x)$, weighted by the coefficients $\alpha_i$.

- The product $\prod_{k=1}^3 \left(x - \omega^{N-k}\right)$ ensures $c(x)$ vanishes at $x = \omega^{N-1}$, $\omega^{N-2}$, $\omega^{N-3}$. This vanishing polynomial enforces that the constraints hold across the entire evaluation domain, including the last three points, ensuring thorough and robust constraint checking.

**Preserving constraints linear independence**

Simply adding the constraint polynomials without weighting them with $\alpha_i$ could result in the loss of linear independence between the constraints. If multiple constraints have similar structures or overlap in their formulations, their sum might simplify or even cancel out, making it harder to distinguish whether all individual constraints are truly satisfied.

For example:

- Let $c_1(x)$ and $c_2(x)$ be constraint polynomials, each expected to evaluate to zero at specific points in the domain $\mathbb{D}$.

- If we sum the polynomials without random coefficients ($c(x) = c_1(x) + c_2(x)$), then $c(x)$ could be zero at points where $c_1(x)$ and $c_2(x)$ have opposite non-zero values, leading to cancellation.

- This cancellation allows a prover to falsely satisfy the aggregated constraint without satisfying the individual ones.

- By introducing random coefficients, $c(x) = \alpha_1 c_1(x) + \alpha_2 c_2(x)$, the likelihood of accidental cancellation is minimized.


#### 2.3.4 - Quotient Polynomial

The quotient polynomial is computed as:

$$
q(x) = \frac{c(x)}{X^N - 1}
$$

Dividing by $X^N - 1$ ensures that the aggregated constraints encoded in $c(x)$ are enforced across the entire evaluation domain $\mathbb{D}$. The division reduces the degree of the resulting polynomial, making it appropriate for further steps in the SNARK protocol.

#### 2.3.5 - Commit to the quotient polynomial and sample evaluation point

Prover commits to the quotient polynomial $q$
$$
C_q = \text{PCS.Commit}(q)
$$

And receives the evaluation point $\zeta$ in reponse

$$
\zeta \leftarrow \text{FS}(C_q)
$$

#### 2.3.6. Evaluate quotient polynomial

Evaluate the relevant polynomials at the sampled evaluation point $\zeta$

$$p_{x,\zeta}=p_x(\zeta)$$

$$p_{y,\zeta}=p_y(\zeta)$$

$$s_\zeta=s(\zeta)$$

$$b_\zeta=b(\zeta)$$

$$acc_{ip,\zeta}=acc_{ip}(\zeta)$$

$$acc_{x,\zeta}=acc_x(\zeta)$$

$$acc_{y,\zeta}=acc_y(\zeta)$$

#### 2.3.7. Linearization polynomial

Linearized parts of constraint polynomials.

For a constraint of the form $C = C(c_1(x),...,c_k(x),c_1(\omega x),...,c_k(\omega x))$, where $c_i$'s are of degree $n$, and an evaluation point $\zeta$, it is a degree $n$ polynomial $r = C(c_1(\zeta),...,c_k(\zeta),c_1(x),...,c_k(x))$.

- Accumulator inner product ($c_1$) linearized

$$l_1(x)=(\zeta - \omega^{N-4})acc_{ip}(x)$$

- Conditional addition accumulators ($c_{2,3}$) linearized

$$l_2(X)=(\zeta-\omega^{N-4})\bigl(b_\zeta(acc_{x,\zeta}-p_{x,\zeta})^2acc_x(X)+(1-b_\zeta)acc_y(X)\bigr)$$

$$l_3(X)=(\zeta-\omega^{N-4})\Bigl(\bigl(b_\zeta(acc_{y,\zeta}-p_{y,\zeta})+1-b_\zeta\bigr)acc_x(X)+b_\zeta(acc_{x,\zeta}-p_{x,\zeta})acc_y(X)\Bigr)$$

- Booleanity ($c_4$) and boundary constraints ($c_{5..7}(x)$) linearized

$$l_4(x) = l_5(x) = l_6(x) = l_7(x) = 0$$ 

- Linearized constraints are aggregated using $\{\alpha_i\}$ coefficients.

$$l(x)=\sum_{i=1}^7\alpha_i l_i(x)$$

- Evaluate at $\zeta \omega$

$$l_{\zeta\omega}=l(\zeta\omega)$$

#### 2.3.8. Sample PCS aggregation coefficients

$\nu_i$ and compute the aggregate polynomial $agg$.

$$
\{\nu_i\}_{i=1}^8 \leftarrow \text{FS}(p_{x,\zeta}, p_{y,\zeta}, s_\zeta, b_\zeta, acc_{ip,\zeta}, acc_{x,\zeta}, acc_{y,\zeta}, l_{\zeta\omega})
$$

$$
agg(x)=\nu_1p_x(x)+\nu_2p_y(x)+\nu_3s(x)+\nu_4b(x)+\nu_5acc_{ip}(x)+\nu_6acc_x(x)+\nu_7acc_y(x)+\nu_8q(x)
$$

#### 2.3.9. Commitments Openings Proofs

Open the aggregate polynomial $agg(x)$ at $\zeta$ and the linearization polynomial $l(x)$ at $\zeta\omega$.

$$\Pi_\zeta=PCS.Open(agg,\zeta)$$

$$\Pi_{\zeta\omega}=PCS.Open(l,\zeta\omega)$$

#### 2.3.10. Proof construction

$$\Pi=(C_b,C_{acc_{ip}},C_{acc_x},C_{acc_y},p_{x,\zeta},p_{y,\zeta},s_\zeta,b_\zeta,acc_{ip,\zeta},acc_{x,\zeta},acc_{y,\zeta},C_q,l_{\zeta\omega},\Pi_\zeta,\Pi_{\zeta\omega})$$


---

## 3 Verifier

### 3.1 - Pre-processed Input

$$(C_{p_x}, C_{p_y}, C_s)$$

These are commitments to the $x$-coordinates and $y$-coordinates of the public keys in the ring and ring selector prepared during the pre-processing phase.

#### Public Input

$$R = (r_x, r_y)$$
 
The claimed point on the elliptic curve, allegedly $PK_m + tH + S$, where:
- $PK_m$ is the public key corresponding to the validator’s index $m$ who prepared the proof.
- $t$ is the validator’s one-time secret scalar.
- $H$ is a known base point.

#### Proof

$$
\Pi = (C_b, C_{acc_{ip}}, C_{acc_x}, C_{acc_y}, p_{x,\zeta}, p_{y,\zeta}, s_\zeta, b_\zeta, ip_{\zeta}, ac_{x,\zeta}, ac_{y,\zeta}, C_q, l_{\zeta\omega}, \Pi_\zeta, \Pi_{\zeta\omega})
$$

- **Commitments**: $C_b, C_{acc_{ip}}, C_{acc_x}, C_{acc_y}, C_q$
- **Evaluations**: $p_{x,\zeta}, p_{y,\zeta}, s_\zeta, b_\zeta, acc_{ip,\zeta}, acc_{x,\zeta}, acc_{y,\zeta}$
- **Opening Proofs**: $\Pi_\zeta, \Pi_{\zeta\omega}$

### Verifier’s Initial Task

1. **Understand the Commitments**:
- The commitments $C_{p_x}, C_{p_y}$ relate to the public keys in the ring and will be used to check the public input $R$.
- The commitments $C_b, C_{ip}, C_{ac_x}, C_{ac_y}, C_q$ correspond to the prover’s polynomials and will be verified against the provided evaluations.

2. **Prepare for Evaluation**:
   - The verifier will later check that the evaluations $p_{x,\zeta}$, $p_{y,\zeta}$, $s_\zeta$, $b_\zeta$, $ip_{\zeta}$, $ac_{x,\zeta}$, $cc_{y,\zeta}$ are consistent with the committed polynomials.
   
### 3.2 - Verification Algorithm

#### 1: Recover Fiat-Shamir Challenges

$$\{\alpha_i\}_{i=1}^7 \leftarrow \text{FS}(C_b, C_{ip}, C_{acc_x}, C_{acc_y})$$

$$\zeta \leftarrow \text{FS}(C_q)$$

$$\{\nu_i\}_{i=1}^8 \leftarrow \text{FS}(p_{x,\zeta}, p_{y,\zeta}, s_\zeta, b_\zeta, acc_{ip,\zeta}, acc_{x,\zeta}, acc_{y,\zeta}, l_{\zeta\omega})$$

#### 2. Contributions of the constraints evaluated at $\zeta$

Note the tilde above some of the constraint polynomials, this exacerbates the fact that these indeed are only a part of the constriaints polynomials, i.e. the component evaluated at $x = \zeta$. They are missing the component evaluated at $x \omega = \zeta \omega$ which is added later by the linearization aggregated polynomial.

$$\tilde{c}_{1,\zeta}=-(acc_{ip,\zeta}+b_\zeta s_\zeta)(\zeta-\omega^{N-4})$$

$$\tilde{c}_{2,\zeta}=\left\{b_\zeta\left[(acc_{x,\zeta}-p_{x,\zeta})^2(acc_{x,\zeta}+p_{x,\zeta})-(p_{y,\zeta}-acc_{y,\zeta})^2\right]-(1-b_\zeta)acc_{y,\zeta}\right\}(\zeta-\omega^{N-4})$$

$$\tilde{c}_{3,\zeta}=\left\{b_\zeta\left[(acc_{x,\zeta}-p_{x,\zeta})acc_{y,\zeta}+(p_{y,\zeta}-acc_{y,\zeta})acc_{x,\zeta}\right]-(1-b_\zeta)acc_{x,\zeta}\right\}(\zeta-\omega^{N-4})$$

$$c_4=b_{\zeta}(1-b_{\zeta})$$

$$c_5=(acc_{x,\zeta}-s_x)L_0(\zeta)+(acc_{x,\zeta}-r_x-s_x)L_{N-4}(\zeta)$$

$$c_6=(acc_{y,\zeta}-s_y)L_0(\zeta)+(acc_{y,\zeta}-r_y-s_y)L_{N-4}(\zeta)$$

$$c_7=acc_{ip,\zeta}L_0(\zeta)+(acc_{ip,\zeta}-1)L_{N-4}(\zeta)$$

#### 3. Evaluation of the quotient polynomial at $\zeta$

Aggregate the contributions together with the linearization polynomial evaluated at $\zeta \omega$ to find the evaluation of the quotient polynomial at $\zeta$:

$$q_{\zeta}=\frac{(\sum_{i=1}^7\alpha_ic_i+l_{\zeta\omega})\prod_{k=1}^3(\zeta-\omega^{N-k})}{\zeta^N-1}$$
   
#### 4. Verify the aggregate opening at $\zeta$

Compute the aggregate commitment $C_{agg}$ using the PCS aggregation coefficients $\nu_i$:

$$C_{agg} = \nu_1 C_{p_x} + \nu_2 C_{p_y} + \nu_3 C_s + \nu_4 C_b + \nu_5 C_{acc_{ip}} + \nu_6 C_{acc_x} + \nu_7 C_{acc_y} + \nu_8 C_q$$
  

Compute the aggregate evaluation $agg_\zeta$ using the same coefficients:

$$agg_\zeta = \nu_1 p_{x,\zeta} + \nu_2 p_{y,\zeta} + \nu_3 s_\zeta + \nu_4 b_\zeta + \nu_5 acc_{ip,\zeta} + \nu_6 acc_{x,\zeta} + \nu_7 acc_{y,\zeta} + \nu_8 q_\zeta$$

Verify the aggregate polynomial at $\zeta$ with the opening proof $\Pi_\zeta$:

$$\text{PCS.Verify}(C_{agg}, \zeta, agg_\zeta, \Pi_\zeta)$$

#### 5. Compute commitment to the linearization polynomial

$$C_{l_1}=(\zeta-\omega^{N-4})C_{acc_{ip}}$$

$$C_{l_2}=(\zeta-\omega^{N-4})\left[b_\zeta(acc_{x,\zeta}-p_{x,\zeta})^2C_{acc_x}+(1-b_\zeta)C_{acc_y}\right]$$

$$C_{l_3}=(\zeta-\omega^{N-4})\left\{\left[b_\zeta(acc_{y,\zeta}-p_{y,\zeta})+1-b_\zeta\right]C_{acc_x}+b_\zeta(acc_{x,\zeta}-p_{x,\zeta}) C_{acc_y}\right\}$$

$$C_l=\sum_{i=1}^3\alpha_iC_{l_i}$$

#### 6. Verify the aggregate openning of the linearization polynomial at $\zeta\omega$

$$PCS.Verify(C_{l},\zeta\omega,l_{\zeta\omega},\Pi_{\zeta\omega})$$

